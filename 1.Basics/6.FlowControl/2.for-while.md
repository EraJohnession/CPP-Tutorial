
&emsp;
# 循环结构
- 循环结构有 for、while、do-while



## 1 for 
>for 循环语句的格式是∶
```c++
for (initialization; condition; increase) statement;
```

按以下方式工作∶

（1）执行初始化initialization。通常是设置一个计数器变量（counter variable）的初始值，初始化仅被执行一次。    

（2）检查条件 condition，如果条件为真，就继续循环，否则循环结束，循环中的语句 statement被跳过。

（3）执行语句 statement。像以前一样，它可以是一个单独的语句，也可以是一个由花括号（{}）括起来的语句块。

（4）最后增值域（increase field）中的语句被执行，循环返回第2 步。

>示例3.12，for循环使用
```c++
#include <iostream>
using namespace std;
int main ()
{
    for (int n=10; n>0; n--) {
    cout << n << ", ";
    }
    cout << "FIRE!\n";
return 0;
} 
```

&emsp;&emsp;初始化 initialization 和增值 increase 域是可选的（可以为空）。但这些域为空的时候，它们和其他域之间间隔的分号不可以省略。例如，我们可以写for（;n<10;）来表示没有初始化和增值语句，或 for （;n<10;n++）来表示有增值语句但没有初始化语句。

&emsp;&emsp;另外，我们也可以在 for 循环初始化或增值域中放一条以上的语句，中间用逗号（，）隔开。例如，假设想在循环中初始化一个以上的变量，可以用以下程序来实现∶
```c++
for (n=0, i=100; n!=i; n++, i--)
{
    // whatever here...
}
```

&emsp;&emsp;如果 n和i在循环内部都不被改变，这个循环将被执行 50 次。


&emsp;
## 2 while 
>while循环语句的格式是∶
```c++
while （表达式expressior） 语句statement
```

&emsp;&emsp;它的功能是当expression 的值为 true 时重复执行 statement。例如，下面将用 while 循环来写一个倒计数程序。

>示例，while循环结构的使用
```c++
#include <iostream>
using namespace std;
int main ()
{
    int n;
    cout << "Enter the starting number > ";
    cin >> n;
    while (n>0) {
        cout << n << ", ";
        --n;
    }
    cout << "FIRE!\n";
    return 0;
} 
```

&emsp;&emsp;我们必须提供一些方法使得条件可以在某个时刻变为False，否则循环将无限重复下去。在这个例子里，我们用语句-n;使得循环在重复一定的次数后变为 false; 当 n 变为 0时，倒计数结束。

&emsp;
## 3 do-while 
>do-while 循环语句的格式是∶
```c++
do 语句statement while（条件condition）;
```

&emsp;&emsp;do-while 循环中是先执行 statement 然后才检查条件（condition），而不像while循环中先检查条件然后才执行 statement。这样，即使条件从来没有被满足过，statement 仍至少被执行一次。

&emsp;&emsp;例如，下面的程序重复输出用户输入的任何数值，直到用户输入0为止。

>示例，do-while的使用
```c++
#include <iostream>
using namespace std;
int main ()
{
    unsigned long n;
    do {
        cout << "Enter number (0 to end): ";
        cin >> n;
        cout << "You entered: " << n << "\n";
    } while (n != 0);
    return 0;
} 
```

>示例
```c++
float RandomGaussianValue(float mean, float sigma)
{
  // Box-Muller transformation
  float x1, x2, w, y1;

  do {
    x1 = (float)2. * RandomValue<float>() - (float)1.;
    x2 = (float)2. * RandomValue<float>() - (float)1.;
    w = x1 * x1 + x2 * x2;
  } while ( w >= (float)1. || w == (float)0. );

  w = sqrt( ((float)-2.0 * log( w ) ) / w );
  y1 = x1 * w;

  return( mean + y1 * sigma );
}
```