
&emsp;
# 多维数组

>多维数组的声明
```cpp
type array[dim1][dim2][...]
```
- 多维数组只是一个抽象的概念，因为我们只需要把各个索引的乘积放入一个简单的数组中就可以获得同样的结果

<div align=center>
    <image src="imgs/array.png" width=500>
</div>


&emsp;
>Example 1
- 数组在内存中的本质
- 索引的计算
```c++
#include <iostream>
using namespace std;

int main()
{
    // 数组维度：dim[d1][d2][d3]
    // 数组索引：index[x][y][z] = index[x*(d2*d3) + y*(d2) + d3]

    int a[3][2][2] = {0,1,2,3,4,5,6,7,8,9,10,11};
    // 相当于索引 11 = 2*(2*2) + 1*1 + 1
    cout << a[2][1][1] << endl; 
    return 0;
}
```
>Example 2
- 不同的索引结果

```cpp
#include <iostream>
using namespace std;

int main()
{
    int a[3][2][2] = {0,1,2,3,4,5,6,7,8,9,10,11};
    // address of block 0; point to 4 int
    printf("%s: %p\n", "value of a[0]: ", a[0]);
    // address of block 1; point to 4 int
    // 偏移 16 个字节, 也就是第 1 块开始的位置
    printf("%s: %p\n", "value of a[1]: ", a[1]);
    // cout << "address of block 0: " << a[0] << endl;

    // address of block 0, row 0; point to 2 int
    printf("%s: %p\n", "value of a[0][0]: ", a[0][0]);
    // address of block 0, row 1; point to 2 int
    printf("%s: %p\n", "value of a[0][1]: ", a[0][1]);

    // 为什么出来的不是地址值了？
    printf("%s: %d\n", "value of a[2][0][0]: ", a[2][0][0]);
    printf("%s: %d\n", "value of a[2][0][1]: ", a[2][0][1]);

    return 0;
}
```

>Example 3
- ORB-SLAM3 代码段
```c++
void PnPsolver::estimate_R_and_t(double R[3][3], double t[3])
{
  double pc0[3], pw0[3];

  pc0[0] = pc0[1] = pc0[2] = 0.0;
  pw0[0] = pw0[1] = pw0[2] = 0.0;
  ...
}
```